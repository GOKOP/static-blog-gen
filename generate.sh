#!/bin/sh

get_post_dates() {
	[ -d temp/postdata ] && rm -r temp/postdata
	mkdir temp/postdata

	for file in $(ls posts-md); do
		date=$(echo $file | sed 's|_.*||; s|\.md||')
		echo $date > temp/postdata/$file
	done
}

get_post_dates_git() {
	[ -d temp/postdata ] && rm -r temp/postdata
	mkdir temp/postdata

	# subshell so as not to cd back
	(
		cd posts-md
		for commit in $(git log --oneline --reverse | awk '{print $1}'); do
			date=$(git diff-tree --root --format=%cs $commit | head -n1)
			files="$(git diff-tree --root --no-commit-id --name-only -r $commit)"

			for file in $(echo $files | grep "$1"); do
				[ -z $1 ] && filename=$file || filename=$(echo $file | sed 's|'$1'||')
				if [ ! -f ../temp/postdata/$filename ]; then
					echo $date > ../temp/postdata/$filename
					echo "" >> ../temp/postdata/$filename
				else
					sed '2s|.*|'$date'|' ../temp/postdata/$filename > ../temp/$filename
					mv ../temp/$filename ../temp/postdata/$filename
				fi
			done
		done
	)
}

# converts markdown to html
convert_posts() {
	[ -d temp/posts ] && rm -r temp/posts
	mkdir temp/posts

	for file in $(ls posts-md); do
		pandoc posts-md/$file -f markdown -t html -o temp/posts/$(echo $file | sed 's|.md$|.html|')
	done
}

# generates a full html document for each post
generate_posts() {
	mkdir site/posts

	for file in $(ls posts-md); do 
		date=$(head -n1 temp/postdata/$file)
		[ $(wc -l < temp/postdata/$file) = 2 ] && edit_date=$(tail -n1 temp/postdata/$file)
		year=$(echo $date | sed 's|-.*||')
		title="$(head -n 1 posts-md/$file | sed 's|# ||')"
		html_file=$(echo $file | sed 's|\.md|.html|')
		cat html/common/top-pre-css.html html/post/css.html html/common/top-post-css.html html/post/top.html > temp/top0
		sed 's|<!-- title !-->|'"$title"'|; s|<!-- year !-->|'"$year"'|; s|<!-- date !-->|'$date'|' temp/top0 > temp/top1
	
		if [ -z $edit_date ]; then
			sed 's|.*<!-- edit date !-->.*||' temp/top1 > temp/top2
		else
			sed 's|<!-- edit date !-->|'$edit_date'|' temp/top1 > temp/top2
		fi
	
		cat temp/top2 temp/posts/$html_file html/common/back-to-top.html html/common/footer.html > "site/posts/$html_file"
	done
}

# used in generate_index and generate_roll
# takes middle-page content of each year generated by these functions and builds a full html document
# the first (and only) argument is either "index" or "roll"
finish_years() {
	mkdir site/$1

	for year in $(ls temp/years); do
		year_n=$(grep " $year" temp/year_list | awk '{print $1}')

		# below the notion of "next" and "previous" is kinda mixed up
		# because year_list has years numbered in reverse order
		# "previous" in code means previous on the list, so chronogically it's "next"
	
		if [ $year_n = 1 ]; then # there's no next year, remove the button
			sed 's|^.*<!-- next year !-->.*$||' html/$1/top.html > temp/top0
		else
			prev_year=$(grep "$(echo $year_n-1 | bc) " temp/year_list | awk '{print $2}')
			sed 's|<!-- next year !-->|'$prev_year'|g' html/$1/top.html > temp/top0
		fi
	
		next_year=$(grep "$(echo $year_n+1 | bc) " temp/year_list | awk '{print $2}')
	
		if [ -z $next_year ]; then # there's no previous year, delete the button
			sed 's|^.*<!-- prev year !-->.*$||' temp/top0 > temp/top1
		else
			sed 's|<!-- prev year !-->|'$next_year'|g' temp/top0 > temp/top1
		fi
	
		# assign a css class to the nav element so it can be styled accordingly to what's inside
		# (this is done purely to make the example html look the way I imagined it lol)
		if [ $year_n = 1 ]; then
			sed 's|<!-- nav class !-->|nav-left|' temp/top1 > temp/top2
		elif [ -z $next_year ]; then
			sed 's|<!-- nav class !-->|nav-right|' temp/top1 > temp/top2
		else
			 sed 's|<!-- nav class !-->|nav-both|' temp/top1 > temp/top2
		fi
	
		sed 's|<!-- year !-->|'$year'|' temp/top2 > temp/top3
		sed 's|<!-- title !-->|'$year'|' html/common/top-pre-css.html > temp/top4
		cat temp/top4 html/$1/css.html html/common/top-post-css.html temp/top3 temp/years/$year html/common/footer.html > site/$1/$year.html
	done
}

generate_roll() {
	[ -d temp/years ] && rm -r temp/years
	mkdir temp/years

	# for counting years - done to determine if the current year is the first or the last one later
	year_n=0
	
	for file in $(ls -r posts-md); do
		date=$(head -n1 temp/postdata/$file)
		[ $(wc -l < temp/postdata/$file) = 2 ] && edit_date=$(tail -n1 temp/postdata/$file)
		year=$(echo $date | sed 's|-.*||')
		html_file=$(echo $file | sed 's|\.md|.html|')
	
		# make a numbered list of years so that finish_years() can later know when it's the first or the last one
		if [ -z $prev_year ] || [ $year != $prev_year ]; then
			year_n=$(echo $year_n+1 | bc)
			echo "$year_n $year" >> temp/year_list
		fi
	
		sed 's|<!-- date !-->|'$date'|; s|<!-- post !-->|'$html_file'|' html/roll/post-head.html > temp/top
	
		if [ -z $edit_date ]; then # if there's no edit date then delete the line
			sed 's|.*<!-- edit date !-->.*||' temp/top >> temp/years/$year
		else
			sed 's|<!-- edit date !-->|'$edit_date'|' temp/top >> temp/years/$year
		fi
	
		cat temp/posts/$html_file html/common/back-to-top.html >> temp/years/$year
		
		prev_year=$year
	done
	
	finish_years roll
}

generate_index() {
	[ -d temp/years ] && rm -r temp/years
	mkdir temp/years

	year_n=0
	prev_year=-1
	
	for file in $(ls -r posts-md); do
		date=$(head -n1 temp/postdata/$file)
		year=$(echo $date | sed 's|-.*||')
		month=$(echo $date | sed 's|....-||; s|-..$||')
		month_word=$(grep $month months | awk '{print $2}')
		title=$(head -n 1 posts-md/$file | sed 's|# ||')
		html_file=$(echo $file | sed 's|\.md|.html|')
	
		if [ $prev_year = -1 ]; then 
			# this is the first iteration - create a new file and start a new month list
			year_n=$(echo "$year_n + 1" | bc)
			echo "$year_n $year" > temp/year_list
	
			echo "<h2>$month_word</h2>" > temp/years/$year
			echo "<ul>" >> temp/years/$year
			echo "<li><a href='../posts/$html_file'>$date – $title</a></li>" >> temp/years/$year
	
		elif [ $year = $prev_year ] && [ $month = $prev_month ]; then
			# just append a new list entry
			echo "<li><a href='../posts/$html_file'>$date – $title</a></li>" >> temp/years/$year
	
		elif [ $year = $prev_year ]; then # same year but a new month, close previous list and start a new one
			echo "</ul>" >> temp/years/$year
			echo "<h2>$month_word</h2>" >> temp/years/$year
			echo "<ul>" >> temp/years/$year
			echo "<li><a href='../posts/$html_file'>$date – $title</a></li>" >> temp/years/$year
		else # it's a new year, close the previous list and create a new file
			year_n=$(echo "$year_n + 1" | bc)
			echo "$year_n $year" >> temp/year_list
	
			echo "</ul>" >> temp/years/$prev_year
			echo "<h2>$month_word</h2>" > temp/years/$year
			echo "<ul>" >> temp/years/$year
			echo "<li><a href='../posts/$html_file'>$date – $title</a></li>" >> temp/years/$year
		fi
	
		prev_year=$year
		prev_month=$month
	done
	
	echo "</ul>" >> temp/years/$year
	
	finish_years index
}

generate_site_index() {
	pandoc index.md -f markdown -t html -o temp/index
	sed 's|<!-- title !-->|Main page|' html/common/top-pre-css.html > temp/top0
	cat temp/top0 html/site-index/css.html html/common/top-post-css.html temp/index html/common/footer.html > site/index.html
}


# -------------------- end of function declarations --------------------


# check if there's anything to generate
posts="$(ls posts-md)"
[ -z "$posts" ] && echo "Write some posts first!" && exit

[ -d site ] && rm -r site
mkdir site

[ -d temp ] && rm -r temp
mkdir temp

# is posts-md its own git repo?
cd posts-md
toplevel="$(git rev-parse --show-toplevel 2>/dev/null)"
excode=$?
cd ..

if [ $excode != 0 ]; then 
	get_post_dates
elif [ "$toplevel" = "$(pwd)/posts-md" ]; then
	get_post_dates_git
else
	cd posts-md
	post_path="$(echo $(pwd) | sed 's|'$(git rev-parse --show-toplevel)'/||; s|$|/|')"
	cd ..
	get_post_dates_git "$post_path"
fi

convert_posts
generate_posts
generate_roll
generate_index
generate_site_index

cp -r css site/

last_year=$(ls site/index | tail -n 1)
ln -s $last_year site/index/index.html
ln -s $last_year site/roll/index.html

rm -r temp
